Thanks, I’ll investigate how your smart context system might be locking AI edits to previously touched cells, despite being given follow-up prompts to expand. I’ll examine the context logic, any state retention, and how the AI interprets editing scope, especially around `selectedData` and `nearbyRange`.

I’ll get back to you with a diagnosis and suggestions shortly.


# AI Edits Confined to Initial Cells – Diagnosis and Fixes

## Diagnosis

In follow-up chats, the AI continues to modify only the initially selected cells because the spreadsheet context provided to the AI isn’t expanding or updating between messages. Essentially, the AI keeps seeing the same snapshot of the sheet (the same range and data) every time, so it doesn’t “know” about new regions to work on. Logs confirm that the Excel context remains fixed on the original range (e.g. a static `A1:Z100` window or whatever cells were first touched) instead of reflecting any newly added areas. Since the session ID stays the same, the AI treats the conversation as continuous, but the context fed into each request is stale. As a result, even if the user’s instruction says “expand into new rows/columns,” the AI’s response targets the same cells it edited before (the only cells it sees in context).

## Root Cause

Several factors in the context-building system are causing the AI to be “stuck” on the original cells:

* **Static Context Window / Selection** – The “smart” context logic is effectively disabled or not dynamic. Currently, if no new selection is made by the user, the backend uses a fixed range for context (often defaulting to something like `A1:Z100`). This static range was likely a stopgap to give the AI some data without overloading it, but it means the context doesn’t shift with the AI’s edits. The backend’s context builder always builds around the same initial range (in fact, the `ContextBuilder` in Go defaults to `A1:Z100` for lack of a better hint). In the absence of an updated user selection, subsequent chat requests keep using that same range as `selectedData/nearbyData`. The chat logs note *“the Excel context is stuck showing the same range (A1\:Z100) … The AI keeps seeing the same cells it already edited instead of moving to new areas”*. Consequently, the AI has no indication of where to put new content.

* **Context Not Updated Between Messages** – The system doesn’t proactively update the context scope after the AI performs an operation. Because the user isn’t forced to select a new range each time, the last *explicit* selection remains in effect. For example, if the user initially selected A1\:G3 and the AI filled that area, on the next message the user might say “now do the next part,” but if they haven’t clicked a new range, the add-in still reports the context around A1\:G3. There is no logic to automatically broaden or shift the focus to, say, the next empty rows or columns. In the backend session state, `session.Selection` remains the same and the context builder keeps returning the same nearby range. In short, the context scope is essentially cached from the first message. This explains why *“the AI keeps trying to write to the same cells – it doesn't know where else to write because the context isn't updating”*.

* **Partial Excel Context Data** – Until recently, a bug in how the Excel context was passed and parsed made the backend unaware of new data, reinforcing the issue. The frontend was sending `selectedData`/`nearbyRange` as nested objects that the Go backend didn’t parse correctly, causing it to think the sheet was empty even after the AI wrote data. In that scenario, the AI would literally repeat the initial edit because the backend kept telling it the spreadsheet had no data (a worst-case example of context not carrying over). A fix has been outlined to adjust the JSON structure and parsing so that `selectedData` is recognized in the root context map and so that “nearby” context is included under the proper key. This parsing issue contributed to the AI’s lack of awareness of its own prior edits.

* **Mismatch in Context Keys (Frontend vs Backend)** – The frontend’s chat payload currently uses the key `nearbyRange` for surrounding cells, whereas the backend code is expecting `nearbyData` (though it falls back to `nearbyRange` if needed). In the code, the message is constructed with a comment noting this should be corrected:

  ```ts
  // Build message payload
  excelContext: {
      … 
      selectedData: excelContext?.selectedData,
      nearbyRange: excelContext?.nearbyData,  // Fix: should be nearbyData not nearbyRange
      activeContext: … 
  }
  ```



  This inconsistency can lead to confusion or missed data in context. In practice, the backend’s `buildFinancialContext` does check for both `nearbyData` and `nearbyRange` and treats them equivalently, so it isn’t completely breaking the logic. But it’s a logical error that could cause maintenance issues and indicates the context system isn’t cleanly implemented. Using a consistent key (`nearbyData`) on both sides will ensure the full nearby context is always picked up.

* **Lack of “Recent Edits” Awareness** – The design intent was to have a “smart context” that infers where to expand next (e.g. if the AI just populated a table, the next request might auto-select the next empty row or related area). That isn’t happening in the current implementation. The code does not track the AI’s last edited range to inform the next context. The session’s `activeContext`/`ContextItem` mechanism is only updated by user selection (the “context pill” feature) and remains `NO RANGE SELECTED` if the user hasn’t explicitly picked a new range. There is no automatic promotion of the last output range to an active context. In effect, the smart context system is *scope-limited to the original user selection* and does not dynamically grow on its own.

## Suggested Fixes

To allow the AI to expand into new areas, the context system needs to become truly dynamic and update between messages. Here are specific changes and improvements to achieve that:

1. **Implement Dynamic Context Expansion:**  Introduce logic to adjust the context window based on recent AI actions or the presence of new data, rather than always using the initial selection or a fixed range. For example, track the range of cells that were written or modified in the last operation and use that as a cue for the next request’s context. If the user hasn’t made a new selection, the system should infer one. This could mean updating `session.Selection` on the backend to the last edited range or merging that range into the “nearby” context for the next prompt. In practice, after each `write_range` or similar operation, the backend knows the target range (from the tool call input). We can store that in the session (e.g. as `session.LastEditRange`) and on the next `ProcessChatMessage`, if the user’s selection is still empty or unchanged, treat `LastEditRange` as the new `selectedRange` or include it in `nearbyData`. Essentially, the context builder should **shift its focus to include the area where changes just occurred or adjacent empty areas**. This aligns with the plan to add *“dynamic context based on activity”* – for instance, if recentActivity.hasEdits, focus the context around those edit locations. By doing so, the AI will see the new area as part of its context and can continue working outward. (In the chat logs, the developer notes that the fix is to make the context capture the user’s current focus *and surrounding empty cells*, rather than staying on A1\:Z100.)

2. **Update Selection via SignalR (if appropriate):** Another approach is to have the front-end reflect AI-driven changes as a new selection. For example, after an AI operation is applied (especially if it’s an “expand” action), the add-in could programmatically select the newly filled range or the next area to work on. Office.js can set the Excel selection; doing this would trigger the existing selection change listener, which in turn calls `UpdateSignalRSessionSelection`. That means the backend’s session would get an updated `SelectedRange` via the `/api/selection-update` endpoint, thus updating context for the next round. This might be a bit intrusive (it moves the user’s view/selection unexpectedly), so it should be used judiciously. Still, it’s an option to ensure the session’s notion of `selectedRange` isn’t stuck on the old cells. If implementing this, also consider highlighting the region where the AI will operate next to make it clear to the user.

3. **Fix Front-end Context Key and Data Passing:** Standardize the context object keys between front-end and backend. The front-end should send `nearbyData` instead of `nearbyRange` in the SignalR `chat_message` payload. The code comment already flags this correction. Making this change (and adjusting any corresponding backend expectations) will remove ambiguity. Moreover, ensure the front-end is sending *complete* context data on each message – that includes the values and formulas for both the selected range and the surrounding range. According to the fix plan, the front-end’s `ExcelService.getSmartContext()` already prepares `selectedData` and `nearbyData` with addresses, values, formulas, etc., but we must confirm those are actually included in the JSON. For instance, after the first AI operation populates cells, `getSmartContext()` should detect the sheet is no longer empty and capture the new used range (it tries to do this by scanning `worksheet.getUsedRange()` when selection is just A1). Verifying and testing this will be important. In short, **send the correct context structure and ensure it’s refreshed**. The backend logs initially showed the context keys were not being parsed, leading to “spreadsheet is empty” messages – with the key mismatch resolved and parsing fixed, the AI will correctly see that data exists and won’t keep treating the sheet as blank.

4. **Improve Backend Context Parsing & Model:** Incorporate the parsing fixes outlined in the development notes to ensure no context data is being dropped. The backend `buildFinancialContext` should already handle both `selectedData` and `nearbyData` from the incoming JSON (falling back to `nearbyRange` for legacy). We should double-check that it uses the **root-level** context fields. The plan suggested modifying `buildFinancialContext` to look in `context[...]` first for `selectedData` before `additionalContext`; the current code does place `selectedData` in the merged context map, so that should be fine. After applying these fixes, add logging or tests to confirm that when the AI adds new data, `hasData` is true and the context’s `DocumentContext` no longer says “Spreadsheet is empty.” This will prevent the AI from resetting the same cells. In essence, once the spreadsheet has content, the model context should reflect a model type or at least not mark it empty.

5. **Smart Context Sizing:** To avoid overwhelming the AI with too much data (the reason dynamic context was toned down originally), implement **adaptive context windows**. The idea is to include enough surrounding data for continuity but not the entire sheet every time. For example, if the sheet is large, context builder could include just a summary or a sampled portion of distant data rather than everything. The code blueprint in the fix plan proposes strategies like focusing on recent edit areas or, if the sheet is very large, sampling the sheet intelligently. We can follow that approach:

   * If the user/AI have been working in a particular section recently, carry that section (and maybe a bit beyond it) into the next prompt’s context.
   * If the sheet has become quite big, don’t always send A1\:Z100; maybe send a few relevant slices (e.g. the current financial model section the AI is working on). This could be done by analyzing the content for boundaries (headers, blank rows, etc.) to identify the block of the model in question.
   * Continue to use the “nearbyData” concept but make it smarter – e.g.,  instead of a fixed +/-20 rows around the selection, adjust those offsets based on how much data is present or needed.

6. **Leverage Active Context (“context pill”) Feature:** Make sure the “activeContext” mechanism can supplement the above. The `activeContext` array in the payload is intended to explicitly highlight a range of interest (e.g. the user clicked a table they want to focus on). You might extend this so that if the AI needs to expand to a new area, the system could programmatically add an entry to `activeContext` for that area. For instance, if we know the next empty row under a populated table, we could include an item like `{type: "selection", value: "Sheet1!A10:G15"}` in the context. This would show up as a mention (perhaps invisible to the user if done behind the scenes) and be included in the AI prompt. Essentially, treat the next target region as a contextual hint. This goes hand-in-hand with tracking recent edits – as soon as the AI fills one section, pre-load the next section as an `activeContext` for the next query. This way the AI will “see” an empty template area to fill.

7. **Testing and Iteration:** After making these changes, test the workflow:

   * Start with an empty sheet, issue a request (the AI creates something in, say, A1\:G10).
   * Then in a second request (with no manual selection change), ask the AI to continue. Verify that the new context now includes at least the range A1\:G10 (so the AI sees what it already did) **and** the next area (e.g. perhaps G11 or H1 onward) so it knows expansion is possible. The AI’s response should then populate new cells instead of circling back to A1.
   * Also test with partial user selections (e.g. user selects a new starting cell and asks AI to continue there) to ensure that overrides still take precedence.
   * Monitor for any cases where the AI might overshoot (the goal is for it to have freedom to expand, but within logical bounds – e.g., it shouldn’t start overwriting unrelated parts of the sheet just because context is broad).

By implementing the above, the AI should no longer be anchored to the originally touched cells. Instead, it will operate with an evolving view of the spreadsheet. The **session context will grow** as the spreadsheet grows, enabling the model to place output in new areas as instructed. In summary, the fix is to make the Excel context **stateful** and **adaptive**: carry forward knowledge of what was just done, and proactively inform the AI where it can safely make the next set of changes. With the context expansion logic restored (in a controlled way) and the front/back-end context format issues resolved, the AI will be able to “see” beyond the initial cells and follow user prompts to extend the spreadsheet into new regions.

**Sources:**

* Gridmate development notes diagnosing static context and repeated edits
* Excel context JSON structure and fix plan
* Front-end context payload construction (comment noting key mismatch)
* Proposed dynamic context strategy (recent edits and adaptive window)
